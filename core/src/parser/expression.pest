// PEG grammar for the melbi expression language (http://pest.rs/)
//
// IMPORTANT: Keep this grammar in sync with tree-sitter/grammar.js
// Changes to syntax must be reflected in both grammars.
//
// This file is organized into the following logical sections:
//
// * Top-level entry point and control structure
// * Primary expressions (if, lambda, literals, identifiers, grouping)
// * Prefix operations (negation, logical not)
// * Infix operations (arithmetic, logical, fallback)
// * Postfix operations (calls, indexing, member access, casting, where)
// * Type expressions (including generic parameters and record types)
// * Composite literals (record, map, array)
// * Scalar literals (boolean, numbers, strings, bytes, format strings)
// * Identifier handling (quoted and unquoted, with reserved word protection)

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }

COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

main = { SOI ~ expression ~ EOI }

// We use a flat grammar since it's easier to maintain and understand, and we control
// the precedence of operators using the Pratt parser.
//
// https://docs.rs/pest/latest/pest/pratt_parser/struct.PrattParser.html
//
// expr = { prefix* ~ primary ~ postfix* ~ (infix ~ prefix* ~ primary ~ postfix* )* }
expression = {
    prefix_op* ~ primary ~ postfix_op* ~ (infix_op ~ prefix_op* ~ primary ~ postfix_op*)*
}

// === primary expressions ===

primary = _{
    literal
  | ident
  | grouped
}

literal = _{ scalar_literal | composite_literal }

grouped = { "(" ~ expression ~ ")" }

// === prefix operations ===
// Prefix operators: negation (-), logical not, if/then/else, lambda (=>), and Option constructor (some)

prefix_op = _{
    neg
  | not
  | if_op
  | lambda_op
  | some_op
}

neg = @{ "-" ~ !(ASCII_DIGIT | ".") }  // Avoid ambiguity with negative numbers.
not = @{ "not" ~ !(ASCII_ALPHANUMERIC | "_") }  // Word boundary to avoid matching `notify` as `not ify`
some_op = @{ "some" ~ !(ASCII_ALPHANUMERIC | "_") }  // Word boundary to avoid matching `something` as `some thing`

if_op = { "if" ~ expression ~ "then" ~ expression ~ "else" }

lambda_op     = { "(" ~ lambda_params? ~ ")" ~ "=>" }
lambda_params = { ident ~ ("," ~ ident)* ~ ","? }

// === infix operations ===

// TODO: add modulo operator.
infix_op = _{
    pow
  | mul
  | div
  | add
  | sub
  | eq
  | neq
  | le
  | ge
  | lt
  | gt
  | not_in
  | in_op
  | and
  | or
  | otherwise_op
}

pow = { "^" }
mul = { "*" }
div = { "/" }
add = { "+" }
sub = { "-" }
eq     = { "==" }
neq    = { "!=" }
le     = { "<=" }
ge     = { ">=" }
lt     = { "<" }
gt     = { ">" }
in_op  = { "in" }
not_in = @{ "not" ~ WHITESPACE+ ~ "in" }
and    = { "and" }
or     = { "or" }

otherwise_op = { "otherwise" }

// === postfix operations ===

postfix_op = _{
    call_op
  | index_op
  | field_op
  | where_op
  | cast_op
  | match_op
}

call_op   =  { "(" ~ call_args? ~ ")" }
call_args = _{ expression ~ ("," ~ expression)* ~ ","? }

index_op = { "[" ~ expression ~ "]" }
field_op = { "." ~ ident }
where_op = { "where" ~ "{" ~ binding_list? ~ "}" }
cast_op  = { "as" ~ type_expr }

match_op       =  { "match" ~ "{" ~ match_arm_list? ~ "}" }
match_arm_list = _{ match_arm ~ ("," ~ match_arm)* ~ ","? }
match_arm      =  { pattern ~ "->" ~ expression }

// === pattern matching ===

// Flat pattern grammar - precedence handled by Pratt parser
pattern = {
    pattern_prefix* ~ pattern_primary ~ pattern_postfix* ~ (pattern_infix ~ pattern_prefix* ~ pattern_primary ~ pattern_postfix*)*
}

pattern_primary = _{
    "(" ~ pattern ~ ")"
  | pattern_literal
  | pattern_wildcard
  | pattern_none
  | pattern_var
}

pattern_prefix  = _{ pattern_some }
pattern_some    = @{ "some" ~ !(ASCII_ALPHANUMERIC | "_") }
pattern_none    = @{ "none" ~ !(ASCII_ALPHANUMERIC | "_") }

// Empty operators for Phase 3 - tokens that will never appear in patterns
// These consume input if matched, avoiding non-progressing repetition issues
pattern_postfix = _{ "\u{FFFF}" }  // Invalid unicode, will never match
pattern_infix   = _{ "\u{FFFF}" }  // Invalid unicode, will never match

pattern_literal  = _{ boolean | float | integer | string | bytes }
pattern_var      = @{ ident }
pattern_wildcard =  { "_" }

// === type names ===

type_expr = {
    record_type
  | type_path ~ type_params?
}

record_type = {
    "Record" ~ "[" ~ type_field_list? ~ "]"
}

type_field = {
    ident ~ ":" ~ type_expr
}

type_field_list = _{
    type_field ~ ("," ~ type_field)* ~ ","?
}

type_path = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

type_params = _{ "[" ~ type_expr ~ ("," ~ type_expr)* ~ "]" }

// === composite literals ===

composite_literal = _{
    record
  | array
  | map
}

// Empty records are special cased to avoid ambiguity with empty map.
record       =  { ("Record" ~ "{" ~ "}") | ("{" ~ binding_list ~ "}") }
binding_list = _{ binding ~ ("," ~ binding)* ~ ","? }
binding      =  { ident ~ "=" ~ expression }

array       =  { "[" ~ array_elems? ~ "]" }
array_elems = _{ expression ~ ("," ~ expression)* ~ ","? }

map            =  { "{" ~ map_entry_list? ~ "}" }
map_entry_list = _{ map_entry ~ ("," ~ map_entry)* ~ ","? }
map_entry      =  { expression ~ ":" ~ expression }

// === scalar literals ===

scalar_literal = _{
    boolean
  | none
  | float // must come before integer
  | integer
  | string
  | bytes
  | format_string // technically a composite literal, but we treat it as a scalar
}

boolean = { "true" | "false" }
none = @{ "none" ~ !(ASCII_ALPHANUMERIC | "_") }  // Word boundary to avoid matching `nonetheless` as `none theless`

// 3.14 3. 3.0e10
// .5, .5e10
// 3e10 3e-10
// 1_000.5_000
float = ${ float_number ~ suffix? }
float_number = ${ "-"? ~ float_literal }
float_literal = _{
    ("." ~ ASCII_DIGIT ~ ("_" | ASCII_DIGIT)*) ~ float_exponent?
  | (ASCII_DIGIT ~ ("_" | ASCII_DIGIT)* ~ "." ~ (ASCII_DIGIT ~ ("_" | ASCII_DIGIT)*)?) ~ float_exponent?
  | (ASCII_DIGIT ~ ("_" | ASCII_DIGIT)* ~ float_exponent)
}
float_exponent = @{ ("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT ~ ("_" | ASCII_DIGIT)* }

integer = ${ integer_number ~ suffix? }
integer_number = ${ "-"? ~ integer_literal }
integer_literal = _{
  bin_integer | oct_integer | hex_integer | dec_integer
}
dec_integer = @{ ASCII_DIGIT ~ ("_" | ASCII_DIGIT)* }
bin_integer = @{ "0b" ~ ("_")* ~ ASCII_BIN_DIGIT ~ ("_" | ASCII_BIN_DIGIT)* }
oct_integer = @{ "0o" ~ ("_")* ~ ASCII_OCT_DIGIT ~ ("_" | ASCII_OCT_DIGIT)* }
hex_integer = @{ "0x" ~ ("_")* ~ ASCII_HEX_DIGIT ~ ("_" | ASCII_HEX_DIGIT)* }

suffix = ${ "`" ~ expression ~ "`" }

string = @{
    ("\"" ~ (string_escape | !("\\" | "\"") ~ ANY)* ~ "\"")
  | ("'" ~ (string_escape | !("\\" | "'") ~ ANY)* ~ "'")
}

bytes = @{
    ("b\"" ~ (bytes_escape | !("\\" | "\"") ~ ANY)* ~ "\"")
  | ("b'" ~ (bytes_escape | !("\\" | "'") ~ ANY)* ~ "'")
}

format_string      = ${
    ("f\"" ~ (format_text | format_expr)* ~ "\"")
  | ("f'" ~ (format_text_single | format_expr)* ~ "'")
}
format_text        = @{
    ("{{" | "}}" | string_escape | !("{" | "}" | "\"") ~ ANY)+
}
format_text_single = @{
    ("{{" | "}}" | string_escape | !("{" | "}" | "'") ~ ANY)+
}
format_expr        = !{
    "{" ~ expression ~ "}"
}

string_escape = _{ common_escape | "\\u" ~ ASCII_HEX_DIGIT{4} | "\\U" ~ ASCII_HEX_DIGIT{8} }
bytes_escape  = _{ common_escape | "\\x" ~ ASCII_HEX_DIGIT{2} }
common_escape = _{ "\\n" | "\\r" | "\\t" | "\\0" | "\\\\" | "\\\"" | "\\'" | "\\" ~ NEWLINE }

// === identifiers ===

ident = @{ quoted_ident | unquoted_ident }

// NOTE: Could be extended in future to allow Unicode (e.g. emojis) if desired
quoted_ident = @{ "`" ~ (ASCII_ALPHANUMERIC | "-" | "_" | "." | ":" | "/")+ ~ "`" }

reserved_words = _{
    ("if" ~ !(ASCII_ALPHANUMERIC | "_"))
  | ("then" ~ !(ASCII_ALPHANUMERIC | "_"))
  | ("else" ~ !(ASCII_ALPHANUMERIC | "_"))
  | ("true" ~ !(ASCII_ALPHANUMERIC | "_"))
  | ("false" ~ !(ASCII_ALPHANUMERIC | "_"))
  | ("not" ~ !(ASCII_ALPHANUMERIC | "_"))
  | ("and" ~ !(ASCII_ALPHANUMERIC | "_"))
  | ("or" ~ !(ASCII_ALPHANUMERIC | "_"))
  | ("in" ~ !(ASCII_ALPHANUMERIC | "_"))
  | ("otherwise" ~ !(ASCII_ALPHANUMERIC | "_"))
  | ("as" ~ !(ASCII_ALPHANUMERIC | "_"))
  | ("where" ~ !(ASCII_ALPHANUMERIC | "_"))
  | ("match" ~ !(ASCII_ALPHANUMERIC | "_"))
  | ("some" ~ !(ASCII_ALPHANUMERIC | "_"))
  | ("none" ~ !(ASCII_ALPHANUMERIC | "_"))
}

unquoted_ident = @{ !reserved_words ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
